#!/usr/bin/env pandda.python

import os, sys, copy

import iotbx.pdb
import iotbx.ccp4_map

import cctbx.maptbx
import cctbx.sgtbx
#import mmtbx.maps.utils
import iotbx.map_tools

import libtbx.phil
from libtbx.utils import Sorry, null_out
from scitbx.array_family import flex

from Giant.Structure.Align import align_chains

from mmtbx.maps.superpose import mask_grid, generate_p1_box

master_params = libtbx.phil.parse("""
align {
    reference = None
        .type = str
    moving {
        pdb = None
            .type = str
        map = None
            .type = str
    }
    output {
        pdb_suffix = '.aligned.pdb'
            .type = str
        map_suffix = '.aligned.map'
            .type = str
        pdb_prefix = None
            .type = str
        map_prefix = None
            .type = str
    }
}
""")

def run(args):
    # Process input arguments
    phil_objects = []
    argument_interpreter = master_params.command_line_argument_interpreter(home_scope="align")

    for arg in args:
        try: 
            command_line_params = argument_interpreter.process(arg=arg)
        except KeyboardInterrupt: 
            raise
        except Exception: 
            raise Sorry("Unknown file or keyword: %s" % arg)
        else: 
            phil_objects.append(command_line_params)

    # Extract Scope object
    working_params = master_params.fetch(sources=phil_objects)
    params = working_params.extract().align

    # Read in the reference structure
    ref_inp = iotbx.pdb.hierarchy.input(params.reference)
    ref_chain = [c for c in ref_inp.hierarchy.chains()][0]

    # Read in the moving structure
    mov_inp = iotbx.pdb.hierarchy.input(params.moving.pdb)
    mov_map = iotbx.ccp4_map.map_reader(params.moving.map)

    # Check the output file style
    if not params.output.pdb_prefix: params.output.pdb_prefix = params.moving.pdb
    if not params.output.map_prefix: params.output.map_prefix = params.moving.map
    
    # Build up a list of rotation matrices and write out transformed maps
    for mov_chain in mov_inp.hierarchy.chains():
        if not mov_chain.is_protein():
            continue
        
        # Align to the reference chain
        lsq = align_chains(mov_chain=mov_chain, ref_chain=ref_chain)
        # Extract the rotation matrix
        rt = lsq.rt()

        # Transform the entire structure and write out
        mov_copy = mov_inp.hierarchy.deep_copy()
        mov_copy.atoms().set_xyz(rt*mov_copy.atoms().extract_xyz())
        mov_copy.write_pdb_file(params.output.pdb_prefix + '.chain{!s}'.format(mov_chain.id) + params.output.pdb_suffix)

        # New change map
        fake_symm = generate_p1_box(ref_inp.hierarchy, buffer=10.0)
        xray_structure = ref_inp.hierarchy.extract_xray_structure(crystal_symmetry=fake_symm)
        f_calc = xray_structure.structure_factors(d_min=2).f_calc()
        fake_map = f_calc.fft_map(resolution_factor=0.33)

        map_data_superposed = cctbx.maptbx.superpose_maps(
            unit_cell_1        = mov_map.unit_cell(),
            unit_cell_2        = fake_symm.unit_cell(),
            map_data_1         = mov_map.data.as_double(),
            n_real_2           = fake_map.n_real(),
            rotation_matrix    = rt.inverse().r.elems,
            translation_vector = rt.inverse().t.elems)

        map_data_superposed = mask_grid(
            xrs      = xray_structure,
            buffer   = 10,
            map_data = map_data_superposed,
            n_real   = fake_map.n_real())

        iotbx.map_tools.write_ccp4_map(
            sites_cart=xray_structure.sites_cart(),
            unit_cell=fake_symm.unit_cell(),
            map_data=map_data_superposed,
            n_real=fake_map.n_real(),
            file_name=params.output.map_prefix + '.chain{!s}'.format(mov_chain.id) + params.output.map_suffix,
            buffer=10)

if __name__ == '__main__':
    
    run(args=sys.argv[1:])


