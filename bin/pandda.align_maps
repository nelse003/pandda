#!/usr/bin/env pandda.python

import os, sys, copy

import iotbx.pdb
import iotbx.ccp4_map

import cctbx.maptbx
import cctbx.sgtbx
#import mmtbx.maps.utils
import iotbx.map_tools

import libtbx.phil
from libtbx.utils import Sorry, null_out
from scitbx.array_family import flex

from Giant.Structure.Align import align_chains

from mmtbx.maps.superpose import mask_grid, generate_p1_box

master_params = libtbx.phil.parse("""
align {
    reference = None
        .type = str
    moving {
        pdb = None
            .type = str
        map = None
            .type = str
    }
    output {
        pdb_suffix = '.aligned.pdb'
            .type = str
        map_suffix = '.aligned.map'
            .type = str
        pdb_prefix = None
            .type = str
        map_prefix = None
            .type = str
        out_dir = './'
            .type = str
    }
}
""")

def run(args):
    # Process input arguments
    phil_objects = []
    argument_interpreter = master_params.command_line_argument_interpreter(home_scope="align")

    if '--show-defaults' in args:
        master_params.show()
        sys.exit()

    for arg in args:
        try: 
            command_line_params = argument_interpreter.process(arg=arg)
        except KeyboardInterrupt: 
            raise
        except Exception: 
            raise Sorry("Unknown file or keyword: %s" % arg)
        else: 
            phil_objects.append(command_line_params)

    # Extract Scope object
    working_params = master_params.fetch(sources=phil_objects)
    params = working_params.extract().align

    # Read in the reference structure
    ref_inp = iotbx.pdb.hierarchy.input(params.reference)
    ref_chain = [c for c in ref_inp.hierarchy.chains()][0]

    print 'ALIGNING TO CHAIN {!s} OF THE REFERENCE STRUCTURE'.format(ref_chain.id)

    # Read in the moving structure
    mov_inp = iotbx.pdb.hierarchy.input(params.moving.pdb)
    mov_map = iotbx.ccp4_map.map_reader(params.moving.map)

    # Unpad the input map
    gridding_first = mov_map.data.origin()
    gridding_last = tuple(flex.int(mov_map.data.all())-2)
    mov_data = cctbx.maptbx.copy(mov_map.data.as_double(), first=gridding_first, last=gridding_last)

    # Check the output file style
    if not params.output.pdb_prefix: params.output.pdb_prefix = os.path.splitext(os.path.basename(params.moving.pdb))[0]
    if not params.output.map_prefix: params.output.map_prefix = os.path.splitext(os.path.basename(params.moving.map))[0]
    
    # Build up a list of rotation matrices and write out transformed maps
    for mov_chain in mov_inp.hierarchy.chains():
        if not mov_chain.is_protein():
            continue

        # Generate output filenames        
        output_pdb = os.path.join(params.output.out_dir, params.output.pdb_prefix + '.chain{!s}'.format(mov_chain.id) + params.output.pdb_suffix)
        output_map = os.path.join(params.output.out_dir, params.output.map_prefix + '.chain{!s}'.format(mov_chain.id) + params.output.map_suffix)

        if os.path.exists(output_pdb):
            print('OUTPUT PDB ALREADY EXISTS: {!s}'.format(output_pdb))
            sys.exit()
        if os.path.exists(output_map):
            print('OUTPUT MAP ALREADY EXISTS: {!s}'.format(output_map))
            sys.exit()
        
        # Align to the reference chain
        lsq = align_chains(mov_chain=mov_chain, ref_chain=ref_chain)
        # Extract the rotation matrix
        rt = lsq.rt()

        # Transform the entire structure and write out
        mov_copy = mov_inp.hierarchy.deep_copy()
        mov_copy.atoms().set_xyz(rt*mov_copy.atoms().extract_xyz())
        mov_copy.write_pdb_file(output_pdb)

        rot_map_data = cctbx.maptbx.rotate_translate_map(
            unit_cell=mov_map.unit_cell(),
#            map_data=mov_map.data.as_double(),
            map_data=mov_data,
            rotation_matrix=rt.inverse().r.elems,
            translation_vector=rt.inverse().t.elems)
        
        iotbx.ccp4_map.write_ccp4_map(
            file_name=output_map,
            unit_cell=mov_map.unit_cell(),
            space_group=cctbx.sgtbx.space_group_info(number=mov_map.space_group_number).group(),
            map_data=rot_map_data,
            labels = flex.std_string(['rotated map. aligned chain {!s} to chain {!s}.'.format(mov_chain.id, ref_chain.id)])  )

#        # New change map
#        fake_symm = generate_p1_box(ref_inp.hierarchy, buffer=10.0)
#        xray_structure = ref_inp.hierarchy.extract_xray_structure(crystal_symmetry=fake_symm)
#        f_calc = xray_structure.structure_factors(d_min=2).f_calc()
#        fake_map = f_calc.fft_map(resolution_factor=0.33)
#
#        map_data_superposed = cctbx.maptbx.superpose_maps(
#            unit_cell_1        = mov_map.unit_cell(),
#            unit_cell_2        = fake_symm.unit_cell(),
#            map_data_1         = mov_map.data.as_double(),
#            n_real_2           = fake_map.n_real(),
#            rotation_matrix    = rt.inverse().r.elems,
#            translation_vector = rt.inverse().t.elems)
#
#        map_data_superposed = mask_grid(
#            xrs      = xray_structure,
#            buffer   = 10,
#            map_data = map_data_superposed,
#            n_real   = fake_map.n_real())
#
#        iotbx.map_tools.write_ccp4_map(
#            sites_cart=xray_structure.sites_cart(),
#            unit_cell=fake_symm.unit_cell(),
#            map_data=map_data_superposed,
#            n_real=fake_map.n_real(),
#            file_name=output_map,
#            buffer=10)

if __name__ == '__main__':
    
    run(args=sys.argv[1:])


