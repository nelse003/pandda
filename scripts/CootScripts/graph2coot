#! /usr/local/python/python2.7.3-64bit/bin/python

import socket
import threading
from threading import Thread
from decimal import Decimal
import struct
import hashlib
import base64
import sys
import time
import random

from Bamboo.Common.Command import CommandManager
from Bamboo.Common.Online.Utils import connectionReferenceObject, socketReferenceObject, threadWithReturnValue
from Bamboo.Common.Online.Utils import create_handshake_resp, decode_message, encode_message_to_send
from Bamboo.Common.Online.Utils import send_message_to_connection
from Bamboo.Common.Online.Utils import establish_outgoing_connection, establish_incoming_connection
from Bamboo.Common.Online.Utils import close_outgoing_connection, close_incoming_connection

INCOMINGPORT = 12346
INCOMINGADDR = ''

OUTGOINGPORT = 12345
OUTGOINGADDR = ''

####################################

def start_coot():
    """Launches an instance of coot"""
    coot = CommandManager('coot')
    coot.SetArguments('--no-guano','/home/npearce/bin/PANDDAs/Scripts/CootScripts/coot_listener_socket.py')
    coot.run_async()
    return coot

def start_firefox():
    """Launches an instance of firefox for the graph viewing"""
    firefox = CommandManager('firefox')
    firefox.SetArguments('/home/npearce/bin/PANDDAs/html/coot_viewer.html')
    firefox.run_async()
    return firefox

def kill_async_process(prog):
    """Kills the instance of prog (actually, waits for it to be killed...)"""
    return prog.join_async()

def read_and_format_data(csvfile):
    """Reads a csv file and converts to a format to be sent to the webserver and to coot"""

    print 'PROCESSING CSV DATA'

    headers = {}

    csv_contents = open(csvfile,'r').readlines()
    csv_headers = csv_contents[0].strip('\n').split(',')
    # Store each line with an index i
    csv_data = [(i, l.strip('\n').split(',')) for i, l in enumerate(csv_contents[1:])]

    pdb_headers = [h for h in csv_headers if 'pdb' in h.lower()]
    mtz_headers = [h for h in csv_headers if 'mtz' in h.lower()]

    headers['csv'] = csv_headers
    headers['pdb'] = pdb_headers
    headers['mtz'] = mtz_headers

    return headers, csv_data

def send_commands_to_coot(coot_commands, outgoing_connection):
    """ Send the command to coot """

    return_data = []

    for command in coot_commands:
        # Print command
        print 'Command for Coot: ', command
        # Send Coot Command
        outgoing_connection.conn.send(command + "# end")
        # Get response
        data = outgoing_connection.conn.recv(1024)
        print 'Response To Command: ', data

        return_data.append(data)

    return return_data

def close_all_open_models(connection):
    """Get the list of open models in coot - AND CLOSE THEM!"""

    # Gets the list of open models from coot
    open_models = send_commands_to_coot(['molecule_number_list()'], connection)[0]
    # Check validity of response
    assert open_models.startswith('return value: [') and open_models.endswith(']') and (';' not in open_models)
    # Evaluate
    open_models = eval(open_models.split('return value: ',1)[1])
    # Close all of the models
    close_commands = ['close_molecule({!s})'.format(num) for num in open_models]
    # Send to coot
    send_commands_to_coot([';'.join(close_commands)], connection)

    return

def create_coot_commands(message, headers, data):
    """Gets the relevant data for message and creates a log command for coot"""

    coot_commands = []

    try:
        datapoint_num = int(message)
    except ValueError:
        return []
    datapoint_row = [d for i,d in data if i==datapoint_num]
    assert len(datapoint_row)==1
    datapoint_row = datapoint_row[0]

    if headers['pdb']:
        for head in headers['pdb']:
            indx = headers['csv'].index(head)
            # Get the pdb filename
            f = datapoint_row[indx]
            coot_commands.append("read_pdb('{!s}')".format(f))

    if headers['mtz']:
        for head in headers['mtz']:
            indx = headers['csv'].index(head)
            # Get the pdb filename
            f = datapoint_row[indx]
            coot_commands.append("auto_read_make_and_draw_maps('{!s}')".format(f))

    if headers['pdb']:
        coot_commands.append("go_to_ligand()")

    if headers['mtz']:
        coot_commands.append("make_last_map_blue()")

    return [';'.join(coot_commands)]

def send_graph_data_to_connection(connection, message, headers, data):
    """Sends the requested list of datapoints to the client"""

    variables = message.strip().split(' v ')

    assert variables[0] in headers['csv'], '{!s} not in {!s}'.format(variables[0], headers['csv'])
    assert variables[1] in headers['csv'], '{!s} not in {!s}'.format(variables[1], headers['csv'])

    index1 = headers['csv'].index(variables[0])
    index2 = headers['csv'].index(variables[1])

    print repr(variables[0])
    print repr(variables[1])

    data_to_send = ["({{ x: {!s} , y: {!s} , label: '{!s}-{!s}-{!s}' , ref: '{!s}' }})".format(d[index1],d[index2],d[0],d[1],d[2],i) for i,d in data]

    # Send Start Message
    send_message_to_connection("Data Transfer Start", connection)
    # Send variables being plotted
    send_message_to_connection(','.join(variables), connection)
    # Send data one row at a time
    for row in data_to_send:
        if 'None' not in row:
            send_message_to_connection(row, connection)
    # Send Terminating Message
    send_message_to_connection("Data Transfer End", connection)

def handle_incoming_message(socket_ref, message, headers, data):
    """ Reads the incoming messages and decides on the appropriate action to take """

    if message.startswith('python|'):
        # Identified as a python command
        command = message.split('python|',1)[1]
        # Get output from command
        output = eval(command)

    elif message.startswith('coot|'):
        # Identified as a coot command
        command = [message.split('coot|',1)[1]]
        # Send command to coot (via outgoing connection)
        response = send_commands_to_coot(command, socket_ref.outgoing)

    elif message.startswith('selected|'):
        # Identified as a Graph Click
        message = message.split('selected|',1)[1]
        # Close all open models
        close_all_open_models(socket_ref.outgoing)
        # Send the selected point's information to the client
        coot_commands = create_coot_commands(message, headers, data)
        # Send command to coot
        open_models = send_commands_to_coot(coot_commands, socket_ref.outgoing)

    elif message == 'initial|request headers':
        # Web page is requesting list of Headers in File
        send_message_to_connection('Headers: '+', '.join(headers['csv']), socket_ref.incoming)

    elif message == 'initial|request data length':
        # Web page is requesting length of data
        send_message_to_connection('Data Length: {!s}'.format(len(data)), socket_ref.incoming)

    elif message.startswith('plot|'):
        # Identified as a data request
        message = message.split('plot|',1)[1]
        # Send the data to the connection
        send_graph_data_to_connection(socket_ref.incoming, message, headers, data)

    return None

def handle_communications(socket_ref, headers, data):
    """ Wait for commands from the incoming connection, and take the appropriate action """

    reference_data=None

    while 1:
        print "Waiting for data from", socket_ref.incoming.addr
        # Incoming Message
        rawdata = socket_ref.incoming.conn.recv(1024)
        # Skip if no data
        if not rawdata:
            print 'No Connection...'
            message = 'No Connection...'
            break
        # Translate Data to String
        message = decode_message(rawdata)
        # Break if a termination signal is received
        if message == '\x03\xe9' or message == 'exit()':
            print 'Termination Signal...'
            break
        # Print message
        print 'Message: '+repr(message)
        # Decide what to do with message
        output = handle_incoming_message(socket_ref, message, headers, data)
        # if output, store as the new reference data
        if output:
            reference_data=output

    # Control whether program restarts connection
    # ('\x03\xe9' message is a dropped connection - will restart)
    if message == 'exit()':
        return 0
    else:
        return 1

####################################

print "Program Start"

print 'IMPORTING DATA'

csvfiles = [f for f in sys.argv[1:] if (f.endswith('.csv') or f.endswith('.scores'))]

if len(csvfiles) != 1:
    raise SystemExit('ONE CSV FILE MUST BE GIVEN AS INPUT')

headers, data = read_and_format_data(csvfiles[0])

# Create an object for holding the sockets
socket_ref = socketReferenceObject()

# Start coot
print 'STARTING COOT'
coot = start_coot()

# Create a socket to talk to coot
print 'CREATING COOT CONNECTION'
socket_ref.outgoing = establish_outgoing_connection(socket_ref.outgoing, OUTGOINGADDR, OUTGOINGPORT)

# Start Web Browser
print 'STARTING FIREFOX'
firefox = start_firefox()

iteration = 0
flag = 1

while flag == 1:

    # Create a socket to respond to javascript requests
    print 'CREATING FIREFOX CONNECTION'
    socket_ref.incoming = establish_incoming_connection(socket_ref.incoming, INCOMINGADDR, INCOMINGPORT)

    # Handle any incoming requests
    flag = handle_communications(socket_ref, headers, data)

    # Close javascript connection
    print 'CLOSING INCOMING CONNECTION'
    return_value = close_incoming_connection(socket_ref.incoming)

    # Prevent infinite loop
    if iteration < 9999999:
        iteration += 1
    else:
        break

    # At the moment BREAK HERE - PREVENT LOOPING
    break

# Send Termination Command to Coot
print('SENDING TERMINATION COMMAND TO COOT')
return_value = send_commands_to_coot(['coot_real_exit(1)'], socket_ref.outgoing)

# Close coot connection
print 'CLOSING OUTGOING CONNECTION'
return_value = close_outgoing_connection(socket_ref.outgoing)

# Kill Coot
print 'WAITING FOR COOT TO BE CLOSED'
coot_return_value = kill_async_process(coot)
# Kill Firefox
print 'WAITING FOR FIREFOX TO BE CLOSED'
fire_return_value = kill_async_process(firefox)

print "Program End"

