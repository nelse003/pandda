#!/usr/bin/env pandda.python

import os, sys, glob, shutil
import wget

import pandas
import iotbx.pdb
import libtbx.easy_mp

from giant.maths.geometry import is_within

def check_for_clashing_ligands():
    pass

def format_ag(ag):
    return 'chain {} and resid {} and altloc "{}"'.format(ag.parent().parent().id, ag.parent().resid(), ag.altloc if ag.altloc else ' ')

def process_line_wrap(line):

    if not line: return None

    try:
        ret = process_line(line)
        return ret
    except KeyboardInterrupt:
        raise SystemExit()
    except Exception as e:
        print e.__class__, e.message
        raise 

def process_line(line):

    pdb_id, pdb_type, pdb_method = line.split('\t')
        
    print 'Processing {}'.format(pdb_id)

    if pdb_type != 'prot':
        return
    elif pdb_method != 'diffraction':
        return

    out_dir = 'pdbs'
    pdb_dir = os.path.join(out_dir, pdb_id[0])        
    pdb_file = os.path.join(pdb_dir, pdb_id+'.pdb')

    if not os.path.exists(pdb_dir): os.mkdir(pdb_dir)

    if not os.path.exists(pdb_file):
        try:
            filename = wget.download('http://www.rcsb.org/pdb/files/{}.pdb'.format(pdb_id))
        except:
            print 'Failed to download:', filename
            raise 
        shutil.move(filename, pdb_file) 
        assert os.path.exists(pdb_file)
   
    try: 
        h = iotbx.pdb.hierarchy.input(file_name=pdb_file).hierarchy
    except:
        print 'Bad PDB File'
        return

    cache = h.atom_selection_cache()
    sel = cache.selection('(not pepnames) and (not water) and (not element H)')
    # Skip if nothing selected
    if sum(sel) == 0: return
    new_h = h.select(sel)
    
    sel_ag = []
    ret_tab = pandas.DataFrame()

    for lig_ag in new_h.atom_groups():

        # Skip if single atom
        if lig_ag.atoms().size() < 5: continue
        # Skip if different occupancies in same residue
        if lig_ag.atoms().extract_occ().standard_deviation_of_the_sample() != 0.0: continue
        # Skip if full occupancy
        if lig_ag.atoms().extract_occ()[0] == 1.0: continue
        # Skip if common small molecule
        if iotbx.pdb.common_residue_names_get_class(lig_ag.resname) == 'common_small_molecule': continue

        # Look for clashes with protein
        not_ag_str = 'not ({})'.format(format_ag(lig_ag))
        not_ag_sel = cache.selection(not_ag_str)
        not_ag = h.select(not_ag_sel)
        clashes = [ag for ag in not_ag.atom_groups() if is_within(1.5, lig_ag.atoms().extract_xyz(), ag.atoms().extract_xyz())]

        print '========================>'
        print lig_ag.resname, '-', format_ag(lig_ag)
        print 'Clashes:', ', '.join([format_ag(ag) for ag in clashes])

        for clash_ag in clashes:
            if lig_ag.parent().is_identical_hierarchy(clash_ag.parent()):
                # Alternate conformers -- need to check occupancies sum to 1
                print 'SAME RG:', format_ag(lig_ag), '-', format_ag(clash_ag)
            else:
                # Different residue -- need to check conformers sum to 1
                print 'DIFF RG:', format_ag(lig_ag), '-', format_ag(clash_ag)    

        if clashes: 
            continue
        else:
            sel_ag.append(lig_ag)

    if not sel_ag: return

    print('\n'.join([   '================================>',
                        'Found "Ligands": '+','.join([ag.resname for ag in sel_ag]),
                        'Occupancies: '+','.join([str(ag.atoms().extract_occ()[0]) for ag in sel_ag])    ]))
        
    ret_str = '\n'.join(['{} - {}'.format(format_ag(ag), str(ag.atoms().extract_occ()[0]))])

    print ret_str

    return (pdb_id, ret_str, ret_tab)

def run():
    pdb_dir = 'pdbs'
    if not os.path.exists(pdb_dir): os.mkdir(pdb_dir)

    pdb_index = "pdb_entry_type.txt"
    if not os.path.exists("pdb_entry_type.txt"):
        print 'Downloading index of the pdb...'
        os.system("wget ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt")
        print '...Done'
    print 'Using PDB file index from {}'.format(pdb_index)

    pdb_entries = open(pdb_index, 'r').read().split('\n')
    num_entries = len(pdb_entries)
    print 'Found {} codes'.format(num_entries)
 
    output = libtbx.easy_mp.pool_map(func=process_line_wrap, args=pdb_entries, processes=5)
       
    print '\n'*5
    print '==========================================================>'        
    print '===> FINISHED'
    print '==========================================================>'        
    out_tab = pandas.DataFrame()
    for ret in output:
        if ret is None: 
            continue

        if isinstance(ret, Exception):
            print ret.__type__, ret.message
            continue       
 
        pdb_id, ret_str, ret_tab = ret
        print '================================================>'        
        print 'PDB CODE: {}'.format(pdb_id)
        print '====================>'        
        print ret_str
    
if __name__=="__main__":
    run()

