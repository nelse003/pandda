#! /usr/local/python/python2.7.3-64bit/bin/python

import os, sys, glob, shutil

from sgcCode.Beehive import BeehiveDatabase

from Bamboo.Macro.Common import isolate_compound_from_file_by_smile
from Bamboo.Wrappers.MtzUtils import convert_intensities_to_amplitudes, apply_rfree_set
from Bamboo.Analysis.Compare.Coords import calculate_rmsd_using_symmetry, calculate_centroid_difference_using_symmetry

try:
    score_file_in = sys.argv[1]
except:
    raise

assert score_file_in.endswith('.csv'), 'A CSV FILE MUST BE PROVIDED AS INPUT'

outdir = os.path.dirname(os.path.abspath(score_file_in))

fitted_out = os.path.join(outdir,'fitted_scores_with_reference.csv')
refine_out = os.path.join(outdir,'refine_scores_with_reference.csv')

assert not (os.path.exists(fitted_out) and os.path.exists(refine_out)), 'Output Files already exist!'

bee = BeehiveDatabase(test=True)
bee_targets = bee.GetTargetsFromBeehive()

# Find out the target from the path
target = [t for t in bee_targets for p in outdir.split('/') if t in p.split('-')]

if not target:
    target = raw_input("What's the Target?: ")
else:
    target = target[0]

score_contents = open(score_file_in, 'r').read().strip().split('\n')

headers = score_contents[0].split(',')
scores = score_contents[1:]

assert headers[0] == 'template', 'Beehive Crystal Numbers must be 1st column in file and have header `template`'
headers.extend(['PRESENT','CORRECT','REFERENCEPDB'])

with open(fitted_out, 'w') as fittedfile:
    fittedfile.write(','.join(headers))
with open(refine_out, 'w') as refinefile:
    refinefile.write(','.join(headers))

# Index of the column corresponding to the model ligand filename
lig_index = headers.index('LIGPDB')

for i, line in enumerate(scores):

    PRESENT = CORRECT = '0'
    REFERENCE = ''
    MINRMSD = 99999

    fields = line.split(',')

    xtal_number = fields[0]
    if '-' not in xtal_number:
        xtal_number = '-'.join([target, xtal_number])

    model_number = bee.GetModelForXtal(xtal_number)
    if len(model_number) > 1:
        raise Exception('More than one model found! {!s}'.format(line))

    if not model_number:
        model_number = ''
    else:
        model_number = model_number[0]
        # Model Number Found - assume it's a hit
        PRESENT = '1'
        # Add target to front of model number
        if '-' not in model_number:
            model_number = '-'.join([target, model_number])
        # Get file name for pdb_path
        pdb_path, map_path = bee.GetPDBPathForModel(model_number)

        if not pdb_path:
            raise Exception('NO PDB FILE HAS BEEN FOUND FOR {!s}'.format(model_number))

        # Check that it matches the model compound in beehive
        model_comp = bee.GetModelCompoundInfoFromBeehive(model_number)
        model_smiles = [model_comp['modcpd1smiles'], model_comp['modcpd2smiles']]
        # Get the compound information
        smiles = bee.GetXtalMountSmilesFromBeehive(xtal_number)

        if smiles not in model_smiles:
            print('Mount Smiles is not the same as modelled smiles! {!s} not in {!s}'.format(smiles, model_smiles))
            continue

        # Create a file where the extracted ligand will be placed
        REFERENCE = os.path.join(outdir,xtal_number+'-reference.lig.pdb')

        reference_files = isolate_compound_from_file_by_smile(pdb_path, REFERENCE, smiles)

        min_rmsd_file = ''
        for ref in reference_files:
            rmsd = calculate_rmsd_using_symmetry(fields[lig_index],ref)
            if rmsd < MINRMSD:
                MINRMSD = rmsd
                min_rmsd_file = ref

        if min_rmsd_file:
            shutil.copy(min_rmsd_file, REFERENCE)
            [os.remove(ref) for ref in reference_files]
        else:
            raise Exception('NO RMSDS CALCULATED! {!s}'.format(xtal_number))

        if MINRMSD < 1:
            CORRECT = '1'

    print i, PRESENT, CORRECT, fields[0], fields[1], MINRMSD, model_number, REFERENCE

    fields.extend([PRESENT,CORRECT,REFERENCE])

    line_to_write = ','.join(fields)

    if '3-fitted' in line:
        output_file = fitted_out
    elif '4-refined' in line:
        output_file = refine_out
    else:
        raise Exception('Unknown Entry: {!s}'.format(line))

    with open(output_file, 'a') as outfile:
        outfile.write('\n' + line_to_write)
